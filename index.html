<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Blue Dragon Fire</title>
  <script src="mandelbrot.js"></script>
  <link rel="icon" type="image/jpeg" href="favicon.jpg">
</head>
<body style="padding: 0; margin: 0; background: black;">
  <canvas id="canvas" width="1280" height="720" style="position: absolute;"></canvas>
  <script>
      'use strict';

      const canvas = document.getElementById('canvas');

      const RENDER_DELAY_MS = 250;
      const ZOOM_FACTOR = 2;

      let posX = 0;
      let posY = 0;
      let zoom = 1;
      let renderDelayTimer = null;  // renderDelayTimer before render starts
      let workers = [];  // active workers
      let generation = 0;  // unique generation counter

      window.addEventListener('load', function() {
          if (!window.Worker) {
              window.alert('Sorry! This browser does not support web workers');
              return;
          }

          console.log(`Using ${navigator.hardwareConcurrency} workers`);

          parseHash();
          updateCanvasSize();
          draw();
      });

      window.addEventListener('hashchange', function() {
          parseHash();
          draw();
      });

      window.addEventListener('resize', function() {
          updateCanvasSize();
          draw();
      });

      canvas.addEventListener('mouseup', function(event) {
          if (event.button !== 1) {
              // Only handle middle click
              return false;
          }

          posX += (canvas.width / 2 - event.offsetX) / zoom;
          posY += (canvas.height / 2 - event.offsetY) / zoom;

          draw();
      });

      canvas.addEventListener('wheel', function(event) {
          if (event.deltaY < 0) {
              // zoom in
              zoom *= ZOOM_FACTOR;
              posX += (canvas.width / 2 - event.offsetX) / zoom;
              posY += (canvas.height / 2 - event.offsetY) / zoom;
          } else {
              // zoom out
              zoom /= ZOOM_FACTOR;
          }

          draw();
      });

      window.addEventListener('keydown', function(event) {
          if (event.key === 'h') {
              zoom = 1;
              posX = 0;
              posY = 0;

              draw();
          }
      });

      function parseHash() {
          const xyscale = window.location.hash.slice(1).split('@', 2);
          const xy = xyscale[0].split(',', 2);

          zoom = parseFloat(xyscale[1]) || 1;
          posX = parseFloat(xy[0]) || 0;
          posY = parseFloat(xy[1]) || 0;
      }

      function updateCanvasSize() {
          canvas.width = window.innerWidth;
          canvas.height = window.innerHeight;
      }

      function updateHash() {
          const hash = `#${posX},${posY}@${zoom}`;
          window.history.pushState(null, '', hash);
      }

      function draw() {
          const ctx = canvas.getContext('2d');
          const midX = canvas.width / 2;
          const midY = canvas.height / 2;

          ctx.font = '12px sans-serif';
          ctx.textAlign = 'center';
          ctx.fillStyle = '#eeffff';
          ctx.fillRect(midX - 60, midY - 13, 120, 19);
          ctx.strokeRect(midX - 60, midY - 13, 120, 19);
          ctx.fillStyle = '#000000';
          ctx.fillText('Rendering fractal...', midX, midY);

          updateHash();

          clearTimeout(renderDelayTimer);
          renderDelayTimer = setTimeout(function() {
              const chunkHeight = 4;
              const chunks = canvas.height / chunkHeight + 1;
              const worklist = Array.from({length: chunks}, (v, i) => i);

              // Kill any remaining workers
              for (const worker of workers) {
                  worker.terminate();
              }

              // Create a new set of workers
              generation += 1;
              workers = [];
              const freeWorkers = [];
              for (let i = 0; i < navigator.hardwareConcurrency; i++) {
                  const worker = new Worker('mandelbrot.js');
                  worker.generation = generation;
                  worker.id = i;

                  workers.push(worker);
                  freeWorkers.push(worker);

                  console.time(`worker ${worker.generation}.${worker.id}`);
              }

              function schedule() {
                  while (freeWorkers.length) {
                      const worker = freeWorkers.pop();
                      const work = worklist.shift();
                      if (work === undefined) {
                          // No more work
                          console.timeEnd(`worker ${worker.generation}.${worker.id}`);
                          worker.terminate();
                          continue
                      }

                      // Returns rendered ImageData
                      worker.onmessage = function(msg) {
                          freeWorkers.push(worker);

                          // Make sure we don't draw the wrong generation
                          if (worker.generation !== generation) {
                              return;
                          }

                          // Draw completed fractal
                          ctx.putImageData(msg.data, 0, y);

                          // Schedule more work
                          schedule();
                      };

                      const y = work * chunkHeight;
                      const options = {
                          scale: zoom,
                          offsetX: midX + (posX * zoom),
                          offsetY: midY + (posY * zoom) - y,
                      };

                      // render([width, height, options])
                      worker.postMessage([canvas.width, chunkHeight, options]);
                  }
              }

              // Kick workers off
              schedule();
          }, RENDER_DELAY_MS);
      }
  </script>
</body>
</html>
